// JavaScript is single - threaded, meaning it can only execute one task at a time in a single call stack.
//  This is because JavaScript follows an event - driven programming model, where tasks are handled asynchronously through event loops.
// Example 1: Synchronous code execution
console.log("Hello");
console.log("World");

// Output:
// Hello
// World

// Example 2: Asynchronous code execution using setTimeout
console.log("Hello");

setTimeout(() => {
  console.log("World");
}, 1000); // Execute after 1 second

// Output:
// Hello
// (after 1 second) World


// The JavaScript engine is the core component responsible for interpreting and executing JavaScript code. It consists of several key components that work together to process and run JavaScript programs efficiently. Here are the main components of a typical JavaScript engine:

// Parser: The parser reads the source code of a JavaScript program and converts it into a data structure called the Abstract Syntax Tree (AST). This tree represents the syntactic structure of the code, including statements, expressions, and their relationships.
// Interpreter: The interpreter takes the AST generated by the parser and executes it line by line. It converts each AST node into machine code or bytecode and performs the corresponding operations defined by the JavaScript code.
// Compiler: In addition to the interpreter, modern JavaScript engines often use a compiler to optimize code execution. The compiler analyzes the code, performs optimizations (such as dead code elimination, constant folding, and inline caching), and generates optimized machine code or bytecode for faster execution.
// Memory Heap: The memory heap is where JavaScript objects, variables, and other data are stored during program execution. It manages memory allocation and deallocation, garbage collection, and memory optimizations to ensure efficient memory usage.
// Call Stack: The call stack is a data structure that keeps track of the execution context of JavaScript functions and their respective stack frames. When a function is called, a new stack frame is pushed onto the call stack, and when the function returns, its stack frame is popped off the stack.
// Here's a simple example of JavaScript code along with an explanation of how the JavaScript engine processes it:

// javascript
// Copy code
function greet(name) {
  return `Hello, ${name}!`;
}

const message = greet('John');
console.log(message);
// Parsing: The JavaScript engine's parser reads the code and creates an AST representing the greet function definition and the message variable declaration.
// Compilation and Execution:
// The compiler analyzes the code and optimizes it if possible. In this case, there may not be significant optimizations as the code is straightforward.
// The interpreter then executes the code step by step:
// It enters the global execution context and encounters the function greet(name) declaration. It creates a function object in memory.
// It encounters the const message = greet('John'); statement and executes it:
// It pushes a new execution context for the greet function onto the call stack.
// Inside the greet function, it creates a new variable name with the value 'John'.
// It executes the template literal and returns the result "Hello, John!".
// It pops the greet function's execution context off the call stack and assigns "Hello, John!" to the message variable.
// It encounters the console.log(message); statement and logs "Hello, John!" to the console.
// Memory Management: Throughout the execution, the JavaScript engine manages memory allocation for variables (name, message) and function contexts (execution contexts for greet).
// Garbage Collection: If there were objects or variables that are no longer in use (e.g., local variables inside functions after they return), the JavaScript engine's garbage collector would reclaim their memory to prevent memory leaks.